### HashCode相关

不使用类创建散列表的时候，不用考虑HashCode的问题

在Java中，equals相当于“==”，Object中的hashCode返回对象在内存中地址的一个int值。hashCode可能

两个对象的hashCode相同，它们不一定相同。

两个对象的hashCode不相同，它们一定不相同

hashCode于“==”是必要条件



#### 红黑树

红黑树就是二叉排序树的升级版，为了避免出现不平衡的情况

其中出现不平衡的情况时，有三种调整的办法，左旋，右旋，变色

左旋是自己变成自己位置的左孩子。右旋是自己变成自己位置的右孩子。

AVL是平衡二叉排序树，对于平衡有很严格的要求

红黑树则是对于AVL用空间作为代价，减少一些AVL树在平衡上的旋转。

红黑树多线程访问友好。



##### 红黑树的性质

1. 节点是红色或黑色
2. 根节点是黑色
3. 所有叶子节点是黑色（叶子节点是NIL节点，为了性质5到叶子节点具有相同数目黑色节点）
4. 从每个叶子到根的所有路径上不能有两个连续的红色节点
5. 从任一节点到其叶子的所有路径包含相同数目黑色节点



##### 红黑树的插入

默认插入的肯定是红色，因为如果是黑色，肯定会破坏性质5



#### ArrayList

ArrayList是可以动态增长和缩减的索引序列，是基于数组实现的List类

ArrayList继承的是AbstractList抽象类，而不是普通List类，因为接口中有抽象的方法，抽象类中可以有抽象的办法，也可以有具体实现的办法，所以这是一些半抽象。

ArrayList底层是一个object数组，可以存放null

ArrayList区别数组的地方就在于可以自己拓展大小，最关键的就是grow方法

ArrayList在查询方面很快，在修改方面很慢

遍历的时候推荐使用for循环





#### Java一些基础

Map是JAVA中映射的一个接口

此接口主要有四个常用的实现类：

**1.HashMap**

概述：访问速度较快，但是遍历的顺序不确定，只允许一条记录的键为null，线程不安全。

实现：HashMap是数组+链表+红黑树（链表长度大于8的时候转换成红黑树）

哈希函数：使用对象的hashcode的高十六位和当前空间取模

**2.Hashtable**

线程安全，但是是遗留类，一般不推荐使用

**Hashtable和HashMap的不同：**

1. HashMap允许key和value为null，前者不允许
2. HashMap扩容为原来的两倍，前者是两倍+1
3. 后者默认初始容量是16，前者是11
4. 后者的值重新计算，签核直接hashCode
5. HashMap中没有contains方法
6. HashMap线程不安全

**3.linkedHashMap**

是HashMap的一个子类，保留了记录的插入顺序，维护一条双向的链表。

**4.TreeMap**

TreeMap实现了SortedMap的接口，能够将保存的记录根据键排序，默认是按照值的升序排序，在使用TreeMap的时候，key必须实现Comparable接口或者在构造的时候传入自定义的Comparator。

底层就是红黑树，顺序和添加顺序无关，只是根据key的自然排序。

JVM

运行时数据区域：在Java虚拟机启动时创建，仅在Java虚拟机退出时销毁

线程隔离数据区：在线程进入或销毁时创建或销毁

**运行时数据区域：**方法区、堆

- 堆：运行时分配实例和数组内存的地方。数组和对象是不能存在栈里面的，因为帧不是被设计用作此目的，帧一旦被创建大小不能更改，所以帧只用来指向堆中对象的应用。在方法结束之前，对象不会被移除，而且对象只能被垃圾回收器移除。

  为了支持垃圾回收的机制：有三种堆：

  1. 新生代
  2. 老年带
  3. 永久代

- 方法区：方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。有一个别名叫做:

  "Non-Heap"

**线程隔离数据区**：程序计数器、虚拟机栈、本地方法栈

- 程序计数器：程序计数器是一块较小的内存，是当前线程所执行行号指示器。不会OOM。
- 虚拟机栈：每个线程都有自己的栈，栈内以帧的形式保存每个线程的Java方法
- 本地方法栈：是保存虚拟机使用的Native方法。



### 永久代

永久代是HotSpot(一种Java虚拟机)的方法区的实现

在Java7之前，方法去位于永久代，永久代和堆相互隔离，永久代的大小在启动JVM的时候有一个固定值，不可变。

在Java8之后，移除了永久代，变成了源空间，class metadata转移到了本地内存。

为什么移除永久代：

1. 字符串存在永久代中，容易出现性能问题
2. 永久代的大小不确定，PermSize指定太小容易导致永久代OOM(Out Of Memory)
3. 永久代的回收效率偏低

#### GC（Garbage Collector）垃圾回收

1. 判断对象存活

   1. 引用计数法：给对象加上引用计数器，判断引用计数器的值，为0就不可能再被使用，但是无法处理循环引用的对象
   2. 可达性分析：判断某一对象是否会被引用到
   3. GC pause，当出现Stop-the-World的请求后，JVM会将所有线程运行到一定的位置（称为safepoint），便会暂停所有线程，进行垃圾回收。

2. JVM的垃圾回收算法

   1. 标记-清除算法
      - 标记阶段：遍历所有的GC root对象，对于所有的可达对象都打上一个标识
      - 清除阶段：对于堆内存进行遍历，如果发现某个对象没有被标记成可达对象，那么将其回收
      - 不足：标记和清除的效率都不高、会产生大量的碎片，内存碎片过多可能导致无法给大对象分配内存
   2. 复制算法
      - 将内存分成大小相等的两块，每次只使用其中的一块，当这一块用完了就将还存活的复制到另一块上面，再将使用过的内存空间进行清理。实际中一般不分成等大小的两份，Eden和Survivor大小比例默认为8:1，保证内存的利用率为90%
      - 缺点：浪费一半的内存，如果不想浪费，那么需要一定的空间进行分配担保，复制的算法在对象存活率较高时就需要进行较多的复制操作。
   3. 标记-整理算法
      - 将存活的对象往内存的一段移动，直接回收边界以外的内存，所以不会产生内存碎片
      - 缺点：效率不高，不光需要标记存活对象，还要整理所有存活对象的引用地址
   4. 分代收集算法
      - 分成老年代和新生代，老年代就是很少垃圾需要回收，新生代就是许多内存空间需要回收，所以不同代就采用不同的回收算法。
      - 新生代：新生代产生很多的临时对象，大量对象需要回收，所以使用复制算法
      - 老年代：回收的对象很少，都是经过几次标记后都是不可回收的状态转移到老年代的，所以仅有少量的对象需要回收，所以使用标记清除或者标记整理法

   #### 具体的GC过程

   在JAVA中，堆分成了两个区域：新生代、老生代，默认的新生与老生的比例为1:2

   

   1. 新生代被划分成三个区，为了更好的管理堆内存中的对象，包括内存的分配和回收，默认比例8:1:1

      - Eden：Java新对象的出生地（当内存很大直接分配到老生区），当内存不够就会触发MinorGc，对新生代进行一次垃圾回收
      - SurvivorTo ：保留了一次MinorGc过程中的幸存者
      - SurvivorFrom：上一次GC的幸存者，这一次Gc的被扫描者

      MinorGC的过程：使用复制算法，将Eden和ServivorFrom的存活对象全部复制到ServivorTo里面，同时年龄+1，清空Eden和ServicorFrom中的对象，最后ServivorTo和ServivorFrom互换

   2. 老年代里面的对象一般比较稳定，所以fullGC不会频繁的执行，只有空间不够的时候才会这样做，根据不同的垃圾回收器会采用不同的算法：标记——清除或者标记——整理，当老年代也装不下的时候，就会抛出OOM异常

#### JVM对象的分配策略

1. 对象优先在Eden分配
2. 大对象直接进入老年代
3. 长期存活的对象直接进入老年代
4. 动态判断：为了更好地适应不同程序内存状况，虚拟机并不硬性要求对象年龄达到某一阈值才能晋升，如果在Survivor像童年林所有对象的综合大于Survivor的一般，那么此时这类对象就可以直接进入老年代

#### JVM的垃圾回收器

并行：一定是同时做的

并发：一段时间内是同时做的

主要理解CMS、G1

![image-20210303153517690](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210303153517690.png)

#### 类的加载

类的加载：指的是将类的.class文件中的二进制数据读入内存，存放在方法区内，之后在堆区创建一个java.lang.class对象，用来封装类的数据结构，提供访问方法区内的数据结构的接口。

#### 类的生命周期（加载->使用->卸载）

类的加载包括：

1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化

这五个阶段中，加载、验证、准备、初始化的顺序是固定的，但是解析阶段不一定。

##### 加载

虚拟机主要完成三个事情：

1. 通过一个类的全限定名来获取其二进制字节流
2. 将字节流所代表的静态存储结构转化为方法区运行时的数据结构
3. 在JAVA堆中生成一个代表这个类的java.lang.Class的对象，作为方法区中这些数据的访问入口

##### 卸载

当满足以下的条件，类会被卸载：

1. 实例都已经被回收
2. 类加载器被回收
3. 没有任何访问该类的方法

##### 连接（包含验证、准备、解析）

- 验证：文件格式验证、元数据验证、字节码验证、符号应用验证
- 准备：为类的**静态变量**分配内存，将其初始化为默认值，如果有ConstantValue的量（就是被final和static同时修饰），直接放入常量池
- 解析：将类中的符号引用转换成直接引用

##### 初始化

初始化是为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化，在Java中对类变量进行初始值设定有两种方式 ：

1. 声明类变量是指定初始值
2. 使用静态代码块为类变量指定初始值

##### 对象的生命周期

创建：在堆中分配内存创建

应用：使用对象

不可视：对象使用完毕，在其可视区域不再使用

不可到达：在GC root中找不到引用了

可收集：GC发现对象不可到达

终结：finalize方法已经执行

释放：对象空间被重置

